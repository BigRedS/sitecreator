#! /usr/bin/perl

use strict;
use Data::Dumper;

use YAML qw/LoadFile/;
use Getopt::Long;

# Directory with config files in it:
my $d_configFiles = "./etc/config/";
# Once we've worked out which config file
# to use, that'll go here:
my $f_config = undef;
# This is the hashref that we'll fill from
# the YAML and command-line options:
my $c;
# How much stuff to print to screen:
my $verbosity = 1;
# Used to store the option passed when the
# user asks for a specific config file:
my $configFilePreference = undef;


# Process some options:
GetOptions(
	"a=s@" => \$c->{'serveraliases'},
	"u=s"  => \$c->{'username'},
	"c=s"  => \$configFilePreference,
	"v=i"  => \$verbosity,
);

# Check we've got a domain. If not, offer
# some small help:
$c->{'domain'} = $ARGV[0];
if ($c->{'domain'} =~ /^\s*$/){
	print usage();
	exit 1;
}

# Deal with that request for a particular config file:
if($configFilePreference){
	my @configFiles = listConfigFiles($d_configFiles);
	my @matchingConfigFiles = grep {/^$configFilePreference/} @configFiles;
	my $numMatched = scalar(@matchingConfigFiles);
	if ($numMatched == 1){
		$f_config = $d_configFiles."/".@matchingConfigFiles[0];
	}else{
		_error("Ambiguous config file choice. Found $numMatched files:", 0);
		if($numMatched > 1){
			foreach(@matchingConfigFiles){
				_error("\t$_", 0);
			}
		}
		_error("Run without '-c' to be presented with a list to choose from");
	}
}else{
	$f_config = chooseConfigFile("./etc/config/");
}
_info( "Using config file '$f_config'");
my $c = LoadFile($f_config);

# Check the domain is sane, and decide whether or not to deduce usernames from it:
if($c->{'domain'} =~ /^([^\.]+)/){
	$c->{'username'} = $1 unless $c->{'username'} =~ /.+/;
	if(my $pid = unixUserExists($c->{'username'})){
		_error("There is already a unix user with the name $c->{'username'} (pid: $pid)");
	}
}else{
	_error("Invalid domain name ('$c->{'domain'}'): must start with a seris of characters that are not full-stops ('.')");
}

# Convert all the 'env' bit of the yaml to environment vars:
setEnvironmentVariables();


# The config file has a list of passwords that will need to be generated.
# We generate and store them here:
my $users = $c->{'users'};
foreach(keys(%$users)){
	_warn("Zero-length password requested for '$_'") if $c->{'users'}->{$_}->{'length'} < 1;
	$c->{'users'}->{$_}->{'password'} = createPassword($c->{'users'}->{$_}->{'length'});
}

# Iterate through the scripts, running each one:
my $scripts = $c->{'scripts'};
foreach(@$scripts){
	my $script = interpretPlaceholders($_);
	$script = $c->{'env'}->{'scripts_dir'}.$script;
	_info("running $script");
	system($script);
}

# # # #
# Returns true of the user exists, false if it doesn't.
sub unixUserExists{
	my $user = shift;
	return getpwnam($user);
}

# I'm sure there's a better name for this. Replaces all the  placeholder 
# strings (%USERNAME% etc.) ith the values that they're a placeholder for.
sub interpretPlaceholders{
	my $line = shift;
	$line =~ s/%USERNAME%/"$c->{'username'}"/g;
	$line =~ s/%TEMPLATES_DIR%/"$c->{'templates_dir'}"/g;
	$line =~ s/%DOMAIN%/"$c->{'domain'}/g;

	if($line =~ /%DOMAINS%/){
		my $domains = $c->{'domain'};
		$domains.=" ".join(" ", @{$c->{'serveraliases'}}) if defined($c->{'serveraliases'});
		$line =~ s/%DOMAINS%/$domains/g;
	}

	if($line =~ /%PASSWORD_(\S+)%/){
		my $passwordName = $1;
		if (my $pw = $c->{'users'}->{$passwordName}->{'password'}){
			$line =~ s/%PASSWORD_$passwordName%/"$pw"/g;
		}
	}

	if($line =~ /%USERNAME_(\S+)%/){
		my $userName = $1;
		my $userSuffix = $c->{'users'}->{$userName}->{'username_suffix'};
		$line =~ s/%USERNAME_$userName%/"$c->{'username'}.$users->{'$userName'}->{'username_suffix'}"/g;
	}

	return $line;
}
# Sets environment vars for each thing defined in the 'env' bit of the config:
sub setEnvironmentVariables{
	my $e = $c->{'env'};
	foreach my $key (keys(%{$c->{'env'}})){
		my $envKey = uc($key);
		$ENV{$envKey} = $c->{'env'}->{$key};
		_info("Set \$ENV{$envKey} to '".$ENV{$envKey}."' ($c->{'env'}->{$key})");
	}
}

# Create a random password:
sub createPassword{
	my $length = shift;
	my @chars = ("A".."Z", "a".."z", 1..9);
	@chars = (@chars, "!", '$', "%", "^", "&", "*", "(", ")", "{", "}", "[", "]", ":", "@");
	@chars = (@chars, "~", ";", "'", "#", "<", ">", "?", ",", ".");
	my $password;
	for(my $i = 0; $i<$length; $i++){
		$password.=$chars[rand($#chars)];
	}
	return $password;
}

# basically 'ls $CONFIG_DIR'
sub listConfigFiles{
	my $d_config = shift;
	opendir(my $dh_config, $d_config) or die "Couldn't open config directory '$d_config' : $!";
	my @f_config = grep{/\.yaml$/} sort(readdir($dh_config));
	return @f_config;
}

# If more than one config file exists, prompts the user to pick one and returns
# the name of the chosen one. If there's only one, just returns the name of that
# file
sub chooseConfigFile{
	my $d_config = shift;
	my @f_config = listConfigFiles($d_config);
	return $d_config."/".$f_config[0] if $#f_config == 0;
	exit 1 if $verbosity < 0;
	_error("Multiple config files found; pick one by number:\n", 0);
	for(my $i = 0; $i<=$#f_config; $i++){
		_error("$i\t$f_config[$i]\n", 0);
	}
	_error( "\n", 0);
	my $choice = <STDIN>;
	return $d_config."/".$f_config[$choice] if($f_config[$choice] =~ /.+/);
}

# Handy for keeping track of/control over various sorts of output:
sub _warn{
	return unless $verbosity > 0;
	my $message = shift;
	chomp $message;
	print STDERR $message."\n";
}

sub _error{
	return unless $verbosity > -1;
	my $message = shift;
	my $exit = shift || 1;
	chomp $message;
	print STDERR $message."\n";
	exit $exit if $exit > 1
}

sub _info{
	return unless $verbosity > 1;
	my $message = shift;
	chomp $message;
	$message =~ s/\n/\nINFO: /g;
	print "INFO: $message\n";
}

sub _log{
	my $message = shift;
	chomp $message;
	$message =~ s/\n/\nLOG:  /g;
	print "LOG:  $message\n";
}

sub usage{
return <<EOF;
sitecreator

Creates sites.

Usage:
 sitecreator [options] domain name
      -a <domains>  List of additional, secondary domains. Perhaps for
                    use as Apache ServerAliases
      -c <file>     Config file to use. Should be in the config file 
      -u <username> username to use, rather than deducing it from the
                    domain name
      -v <number>   Verbosity:
                     2: Informative/debugging output, warnings and errors
                     1: Non-fatal warnings and fatal errors
		     0: Only fatal errors
		    -1: Hide even errors (exits silently on failure)

EOF
}
