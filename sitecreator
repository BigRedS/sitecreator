#! /usr/bin/perl

use strict;
use Data::Dumper;

use YAML qw/LoadFile/;
use Getopt::Long;

my $f_config = findConfigFiles("./etc/config/");
my $c = LoadFile($f_config);

# Process some options:
GetOptions(
	"a=s@" => \$c->{'serveraliases'},
	"u=s"  => \$c->{'username'},
);
$c->{'domain'} = $ARGV[0];

# Check the domain is sane, and decide whether or not to deduce usernames from it:
if($c->{'domain'} =~ /^([^\.]+)/){
	$c->{'username'} = $1 unless $c->{'username'} =~ /.+/;
	if(my $pid = unixUserExists($c->{'username'})){
		_error("There is already a unix user with the name $c->{'username'} (pid: $pid)");
	}
}else{
	_error("Invalid domain name ('$c->{'domain'}'): must start with a seris of characters that are not full-stops ('.')");
}


# The config file has a list of passwords that will need to be generated.
# We generate and store them here:
my $users = $c->{'users'};
foreach(keys(%$users)){
	_warn("Zero-length password requested for '$_'") if $c->{'users'}->{$_}->{'length'} < 1;
	$c->{'users'}->{$_}->{'password'} = createPassword($c->{'users'}->{$_}->{'length'});
}

# Now 
my $scripts = $c->{'scripts'};
foreach(@$scripts){
	my $script = interpretPlaceholders($_);
	_log($script);
}


print Dumper($c);

# # # #

sub unixUserExists{
	my $user = shift;
	return getpwnam($user);
}

sub interpretPlaceholders{
	my $line = shift;
	$line =~ s/%USERNAME%/"$c->{'username'}"/g;
	$line =~ s/%TEMPLATES_DIR%/"$c->{'templates_dir'}"/g;
	$line =~ s/%DOMAIN%/"$c->{'domain'}/g;

	if($line =~ /%DOMAINS%/){
		my $domains = $c->{'domain'};
		$domains.=" ".join(" ", @{$c->{'serveraliases'}}) if defined($c->{'serveraliases'});
		$line =~ s/%DOMAINS%/$domains/g;
	}

	if($line =~ /%PASSWORD_(\S+)%/){
		my $passwordName = $1;
		if (my $pw = $c->{'users'}->{$passwordName}->{'password'}){
			$line =~ s/%PASSWORD_$passwordName%/"$pw"/g;
		}
	}

	if($line =~ /%USERNAME_(\S+)%/){
		my $userName = $1;
		my $userSuffix = $c->{'users'}->{$userName}->{'username_suffix'};
		$line =~ s/%USERNAME_$userName%/"$c->{'username'}.$users->{'$userName'}->{'username_suffix'}"/g;
	}

	return $line;
}

sub createPassword{
	my $length = shift;
	my @chars = ("A".."Z", "a".."z", 1..9);
	@chars = (@chars, "!", '$', "%", "^", "&", "*", "(", ")", "{", "}", "[", "]", ":", "@");
	@chars = (@chars, "~", ";", "'", "#", "<", ">", "?", ",", ".");
	my $password;
	for(my $i = 0; $i<$length; $i++){
		$password.=$chars[rand($#chars)];
	}
	return $password;
}

sub findConfigFiles{
	my $d_config = shift;
	opendir(my $dh_config, $d_config) or die "Couldn't open config directory '$d_config' : $!";
	my @f_config = grep{/\.yaml$/} sort(readdir($dh_config));
	return $d_config."/".$f_config[0] if $#f_config == 0;
	print "Multiple config files found; pick one by number:\n";
	for(my $i = 0; $i<=$#f_config; $i++){
		print "$i\t$f_config[$i]\n";
	}
	print "\n";
	comy $choice = <STDIN>;
	return $d_config."/".$f_config[$choice] if($f_config[$choice] =~ /.+/);
}

sub _warn{
	my $message = shift;
	chomp $messages;
	print STDERR $message."\n";
}

sub _error{
	my $message = shift;
	my $exit = shift || 1;
	chomp $message;
	print STDERR $message."\n";
	exit $exit;
}

sub _log{
	my $message = shift;
	chomp $message;
	print "INFO: ". $message."\n";
}
